**Выбранные опции на второй этап:**

- работа с графикой: GRAPHICS + LAST-KEY (4)
- цикл BEGIN UNTIL (1)
- проверка комментариев про стек (3)
- массивы (2)
- пошаговая отладка, получение текущего стека, памяти, словаря и т.п. (3)
- REPL с readline (5)
- арифметические операции над числами с плавающей запятой (2)

# Отчет(2 часть)

## 1. Арифметические операции над числами с плавающей запятой

### Функциональность:
Для работы с числами с плавающей запятой были добавлены арифметические операции: сложение, вычитание, умножение и деление для типа Float. Эти операции позволяют работать с вещественными числами, что расширяет возможности языка.

### Реализация:
Для операций с плавающими числами были реализованы соответствующие функции:

fadd — сложение двух чисел с плавающей запятой.
fsub — вычитание.
fmul — умножение.
fdiv — деление с проверкой на деление на ноль.
Каждая из этих функций работает аналогично базовым арифметическим операциям, но с типом Float вместо Int. При этом ошибки, такие как деление на ноль, обрабатываются с помощью возвращаемого значения Left "Error".

### Взаимодействие:
Эти функции интегрированы в общий словарь команд, и при выполнении операций над числами с плавающей запятой стек обновляется соответствующим образом.

### Опыт:
Работа с числами с плавающей запятой позволила мне изучить тонкости реализации арифметических операций с этим типом данных, а также научиться корректно обрабатывать исключения, связанные с делением на ноль.


## 2. REPL с readline

### Функциональность:
Для улучшения взаимодействия с пользователем был интегрирован REPL с использованием библиотеки readline. Это добавляет поддержку истории ввода и автозаполнения, что делает использование интерпретатора более удобным и интерактивным.

### Реализация:
Вместо обычного ввода с getLine, был использован runInputT из библиотеки System.Console.Haskeline, что позволяет использовать функцию автозаполнения и историю команд. Для каждой строки, введенной пользователем, вызывается основная логика интерпретатора, включая обработку команд, вывод результатов и управление ошибками.

### Взаимодействие:
REPL взаимодействует с остальной частью программы, вызывая функции для выполнения команд и выводя результаты работы интерпретатора на экран. Это также позволяет интегрировать пользовательские команды и позволяет их тестирование в реальном времени.

### Опыт:
Использование библиотеки haskeline помогло мне лучше понять, как можно улучшить взаимодействие с пользователем в функциональных приложениях, а также изучить принципы работы с текстовым вводом в Haskell.

## 3. Массивы

### Функциональность:
Для поддержки работы с массивами был реализован функционал для создания массивов и доступа к элементам. Команды для работы с массивами позволяют пользователю выделять память для массивов, а также работать с ячейками массива, используя команды CREATE, ALLOT, ! (для записи) и @ (для чтения).

### Реализация:
Для работы с массивами был реализован тип Array и несколько команд:

CREATE — создает новый массив заданного размера.
ALLOT — выделяет память для массива.
! — записывает значение в ячейку массива по индексу.
@ — извлекает значение из массива по индексу.
Каждая команда управляет стеком и массивом в памяти. Стек используется для передачи индексов и значений, а массивы хранятся в отдельной структуре данных.

### Взаимодействие:
Эти команды позволяют пользователю создавать и манипулировать массивами, расширяя функциональность языка.

### Опыт:
Реализация работы с массивами научила меня, как эффективно управлять памятью и хранить данные в динамически выделенных структурах. Также я изучил принципы работы с многомерными структурами данных и их использование в интерпретаторе.


# Отчет по проекту интерпретатора языка программирования Colon

## 1. Тип для команд, результат выполнения и ошибки, стек результатов, арифметика, манипулирование стеком

### Функциональность:
Основой реализации интерпретатора является стек, представленный типом `Stack` (список чисел `[Int]`).
Результаты выполнения команд и возможные ошибки обрабатываются с помощью типа `ColonResult`, который является `Either String Stack`. Это позволяет интерпретатору сигнализировать об ошибках в процессе выполнения.  
Команды представляют собой функции типа `Command`, принимающие стек и возвращающие `ColonResult`.

### Реализация:
Для базовых арифметических операций (“+”, “-”, “*”, “/”, “MOD”) реализованы соответствующие функции (`add`, `sub`, `mul`, `div'`, `mod'`), работающие с вершинами стека.  
Манипуляции со стеком (“dup”, “swap”, “drop”, “over”, “rot”) позволяют изменять расположение элементов на стеке.  
Все команды обрабатывают случаи недостаточного количества элементов в стеке или другие ошибки, возвращая `Left "Error"`.

### Взаимодействие:
Эти функции используются непосредственно в интерпретаторе и словаре команд для выполнения операций над стеком.

### Опыт:
Я научился обрабатывать ошибки в функциональном стиле с помощью `Either`, что позволяет писать более выразительный код без исключений. Также была проработана концепция стека как универсального механизма для интерпретации языков программирования.

---

## 2. Сравнения

### Функциональность:
Команды сравнения (“>”, “<”, “=”) сравнивают вершины стека и возвращают результат (“-1” для True, “0” для False).

### Реализация:
Функции (`gt`, `lt`, `eq`) извлекают два верхних элемента стека и возвращают новый стек с результатом сравнения.  
Логические операции (“and”, “or”, “invert”) работают с булевыми значениями, представленными через -1 и 0.

### Взаимодействие:
Команды сравнения связаны с условными конструкциями (“ifElse”) и циклами, определяемыми пользователем.

### Опыт:
Изучение работы с булевыми значениями в стековом контексте помогло понять внутреннюю работу Forth-подобных языков.

---

## 3. Ввод-вывод

### Функциональность:
Команды (“.”, “CR”, “EMIT”, “KEY”) обрабатывают ввод и вывод данных.  
“.” выводит верхний элемент стека, “CR” печатает перевод строки, “EMIT” выводит символ по его ASCII-коду, а “KEY” считывает символ с клавиатуры.

### Реализация:
Используются функции `putStrLn`, `putChar` и `getChar` в контексте `Either` для обработки возможных ошибок ввода-вывода.

### Взаимодействие:
Команды ввода-вывода связаны с обработкой пользовательских программ и позволяют взаимодействовать с внешним окружением.

### Опыт:
Я освоил использование `liftIO` для безопасного выполнения IO-операций в функциональном стиле.

---

## 4. Строки ." "

### Функциональность:
Команда `."` позволяет выводить строковые литералы, определяемые в программе.

### Реализация:
Строка, следующая за `."`, анализируется функцией `parseStringLiteral`, которая извлекает содержимое до следующей кавычки `"`.  
Вывод строки реализован через `putStr`.

### Взаимодействие:
Эта команда используется в программах для вывода сообщений и интегрируется с парсером.

### Опыт:
Я понял, как парсить и интерпретировать строки с помощью функций для обработки текстовых данных.

---

## 5. Добавление новых слов в словарь, переменные

### Функциональность:
Пользователь может определять новые слова с помощью конструкции `: name body ;`.

### Реализация:
Парсер идентифицирует определение нового слова по токену `:`.  
Функция `defineNewWord` добавляет новое слово в словарь, используя `Map.insert`.  
Тело слова компилируется через `compileWord`, чтобы создать соответствующую команду.

### Взаимодействие:
Эта функциональность обеспечивает расширяемость языка и интеграцию пользовательских команд с остальным функционалом.

### Опыт:
Создание механизма для определения новых слов помогло мне понять, как интерпретаторы поддерживают расширяемость.

---

## 6. Парсинг текста программы, тесты в виде файлов с программами

### Функциональность:
Парсер разбивает программу на токены и преобразует их в команды с использованием словаря.  
Тесты написаны для проверки базовых операций, арифметики и определения новых слов.

### Реализация:
Функция `parseProgramWithDict` вызывает `parseCommand` для каждого токена.  
Тестовые функции проверяют корректность работы интерпретатора с различными командами.

### Взаимодействие:
Парсер используется во всех частях программы для обработки пользовательского ввода.

### Опыт:
Я освоил принципы парсинга текста и автоматическое тестирование.

---

## 7. Парсинг комментариев

### Функциональность:
Комментарии, заключенные в скобки `( ... )`, игнорируются интерпретатором.

### Реализация:
Функция `removeComments` рекурсивно удаляет текст внутри комментариев, поддерживая вложенные комментарии.  
Парсер вызывает эту функцию перед обработкой программы.

### Взаимодействие:
Парсинг комментариев связан с обработкой текста программы, обеспечивая удобство написания кода пользователем.

### Опыт:
Я научился реализовывать поддержку вложенных комментариев, что улучшило мои навыки работы с текстом.

---

## Общий вывод

Этот проект дал мне возможность изучить принципы работы интерпретаторов стековых языков программирования.  
В процессе я освоил обработку ошибок с помощью `Either`, функциональное тестирование и расширяемость языков с использованием динамических словарей.  
Благодаря парсингу и обработке текстовых данных я лучше понял архитектуру языков программирования.
