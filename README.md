**Выбранные опции на второй этап:**

- работа с графикой: GRAPHICS + LAST-KEY (4)
- цикл BEGIN UNTIL (1)
- проверка комментариев про стек (3)
- массивы (2)
- пошаговая отладка, получение текущего стека, памяти, словаря и т.п. (3)
- REPL с readline (5)
- арифметические операции над числами с плавающей запятой (2)


# Отчет по проекту интерпретатора языка программирования Colon

## 1. Тип для команд, результат выполнения и ошибки, стек результатов, арифметика, манипулирование стеком

### Функциональность:
Основой реализации интерпретатора является стек, представленный типом `Stack` (список чисел `[Int]`).
Результаты выполнения команд и возможные ошибки обрабатываются с помощью типа `ColonResult`, который является `Either String Stack`. Это позволяет интерпретатору сигнализировать об ошибках в процессе выполнения.  
Команды представляют собой функции типа `Command`, принимающие стек и возвращающие `ColonResult`.

### Реализация:
Для базовых арифметических операций (“+”, “-”, “*”, “/”, “MOD”) реализованы соответствующие функции (`add`, `sub`, `mul`, `div'`, `mod'`), работающие с вершинами стека.  
Манипуляции со стеком (“dup”, “swap”, “drop”, “over”, “rot”) позволяют изменять расположение элементов на стеке.  
Все команды обрабатывают случаи недостаточного количества элементов в стеке или другие ошибки, возвращая `Left "Error"`.

### Взаимодействие:
Эти функции используются непосредственно в интерпретаторе и словаре команд для выполнения операций над стеком.

### Опыт:
Я научился обрабатывать ошибки в функциональном стиле с помощью `Either`, что позволяет писать более выразительный код без исключений. Также была проработана концепция стека как универсального механизма для интерпретации языков программирования.

---

## 2. Сравнения

### Функциональность:
Команды сравнения (“>”, “<”, “=”) сравнивают вершины стека и возвращают результат (“-1” для True, “0” для False).

### Реализация:
Функции (`gt`, `lt`, `eq`) извлекают два верхних элемента стека и возвращают новый стек с результатом сравнения.  
Логические операции (“and”, “or”, “invert”) работают с булевыми значениями, представленными через -1 и 0.

### Взаимодействие:
Команды сравнения связаны с условными конструкциями (“ifElse”) и циклами, определяемыми пользователем.

### Опыт:
Изучение работы с булевыми значениями в стековом контексте помогло понять внутреннюю работу Forth-подобных языков.

---

## 3. Ввод-вывод

### Функциональность:
Команды (“.”, “CR”, “EMIT”, “KEY”) обрабатывают ввод и вывод данных.  
“.” выводит верхний элемент стека, “CR” печатает перевод строки, “EMIT” выводит символ по его ASCII-коду, а “KEY” считывает символ с клавиатуры.

### Реализация:
Используются функции `putStrLn`, `putChar` и `getChar` в контексте `Either` для обработки возможных ошибок ввода-вывода.

### Взаимодействие:
Команды ввода-вывода связаны с обработкой пользовательских программ и позволяют взаимодействовать с внешним окружением.

### Опыт:
Я освоил использование `liftIO` для безопасного выполнения IO-операций в функциональном стиле.

---

## 4. Строки ." "

### Функциональность:
Команда `."` позволяет выводить строковые литералы, определяемые в программе.

### Реализация:
Строка, следующая за `."`, анализируется функцией `parseStringLiteral`, которая извлекает содержимое до следующей кавычки `"`.  
Вывод строки реализован через `putStr`.

### Взаимодействие:
Эта команда используется в программах для вывода сообщений и интегрируется с парсером.

### Опыт:
Я понял, как парсить и интерпретировать строки с помощью функций для обработки текстовых данных.

---

## 5. Добавление новых слов в словарь, переменные

### Функциональность:
Пользователь может определять новые слова с помощью конструкции `: name body ;`.

### Реализация:
Парсер идентифицирует определение нового слова по токену `:`.  
Функция `defineNewWord` добавляет новое слово в словарь, используя `Map.insert`.  
Тело слова компилируется через `compileWord`, чтобы создать соответствующую команду.

### Взаимодействие:
Эта функциональность обеспечивает расширяемость языка и интеграцию пользовательских команд с остальным функционалом.

### Опыт:
Создание механизма для определения новых слов помогло мне понять, как интерпретаторы поддерживают расширяемость.

---

## 6. Парсинг текста программы, тесты в виде файлов с программами

### Функциональность:
Парсер разбивает программу на токены и преобразует их в команды с использованием словаря.  
Тесты написаны для проверки базовых операций, арифметики и определения новых слов.

### Реализация:
Функция `parseProgramWithDict` вызывает `parseCommand` для каждого токена.  
Тестовые функции проверяют корректность работы интерпретатора с различными командами.

### Взаимодействие:
Парсер используется во всех частях программы для обработки пользовательского ввода.

### Опыт:
Я освоил принципы парсинга текста и автоматическое тестирование.

---

## 7. Парсинг комментариев

### Функциональность:
Комментарии, заключенные в скобки `( ... )`, игнорируются интерпретатором.

### Реализация:
Функция `removeComments` рекурсивно удаляет текст внутри комментариев, поддерживая вложенные комментарии.  
Парсер вызывает эту функцию перед обработкой программы.

### Взаимодействие:
Парсинг комментариев связан с обработкой текста программы, обеспечивая удобство написания кода пользователем.

### Опыт:
Я научился реализовывать поддержку вложенных комментариев, что улучшило мои навыки работы с текстом.

---

## Общий вывод

Этот проект дал мне возможность изучить принципы работы интерпретаторов стековых языков программирования.  
В процессе я освоил обработку ошибок с помощью `Either`, функциональное тестирование и расширяемость языков с использованием динамических словарей.  
Благодаря парсингу и обработке текстовых данных я лучше понял архитектуру языков программирования.
